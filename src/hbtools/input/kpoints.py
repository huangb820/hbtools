from ase.io import read
import seekpath
from pathlib import Path
from ase import Atoms
from .params import KPOINTSParams
from spglib.spglib import get_symmetry_dataset
from rich.console import Console
from rich.table import Table
import typer

console = Console()


fixed_points: dict[str, dict[str, list[float]]] = {
    "hexagonal": {
        "G": [0.0, 0.0, 0.0],
        "M": [0.5, 0.0, 0.0],
        "K": [1 / 3, 1 / 3, 0.0],
        "K1": [2 / 3, 1 / 3, 0.0],
    },
    "tetragonal": {
        "G": [0.0, 0.0, 0.0],
        "M": [0.5, 0.5, 0.0],
        "X": [0.5, 0.0, 0.0],
        "Y": [0.0, 0.5, 0.0],
    },
    "orthorhombic": {
        "G": [0.0, 0.0, 0.0],
        "X": [0.5, 0.0, 0.0],
        "Y": [0.0, 0.5, 0.0],
        "S": [0.5, 0.5, 0.0],
    },
}

default_kpaths = {
    "hexagonal": "G K M G",
    "tetragonal": "G X M Y G",
    "orthorhombic": "G X S Y G",
    "cubic": "G X M G",
    "triclinic": "G X G",  # 如果seekpath检测失败的兜底路径
}


def detect_lattice_type(params: KPOINTSParams) -> str:
    """
    Automatically detect lattice type using ASE + seekpath.
    """
    try:
        structure: Atoms | list[Atoms] = read(params.input_filename, index=0)
        space_group = get_symmetry_dataset(structure, params.sp_symprec)  # type: ignore
        if space_group is None or "number" not in space_group:
            return "hexagonal"  # fallback or handle as needed
        sp_number: int = int(space_group["number"])
        if sp_number in range(143, 195):
            return "hexagonal"
        elif sp_number in range(75, 143):
            return "tetragonal"
        elif sp_number in range(16, 75):
            return "orthorhombic"
        elif 195 <= sp_number <= 230:  # cubic 家族
            return "cubic"
        else:
            return "triclinic"
    except Exception:
        return "hexagonal"


def parse_line_path(params: KPOINTSParams) -> list[str]:
    """
    将空格分隔的高对称点路径解析为列表。
    支持多字符标签（如 M1、M2、K' 这类，只要在点表里有即可）。
    """
    kpath_str: list[str] = [tok for tok in params.kpoint_path.strip().split() if tok]
    return kpath_str


def get_kpoint_path(params: KPOINTSParams) -> dict[str, list[float]]:
    """
    通过 seekpath 获取高对称点路径。
    和默认的合并，默认的覆盖seekpath得到的。
    """
    # 检测晶格类型
    if params.lattice_type:
        lattice_type = params.lattice_type
    else:
        lattice_type = detect_lattice_type(params)

    if params.auto_mode:
        structure = read(params.input_filename, index=0)
        # Ensure structure is a single Atoms object, not a list
        if isinstance(structure, list):
            structure = structure[0]
        cell_for_seekpath = (
            structure.cell,
            structure.get_scaled_positions(),
            structure.get_atomic_numbers(),
        )
        seekpath_result = seekpath.get_path(
            cell_for_seekpath, symprec=params.sp_symprec
        )
        kpath = seekpath_result["point_coords"]
        finally_kpoints_path = {**kpath, **fixed_points[lattice_type]}
    else:
        finally_kpoints_path = fixed_points[lattice_type]
    return finally_kpoints_path


def write_kpoints_file(params: KPOINTSParams):
    """
    根据 params中的模式选择 生成 KPOINTS 文件的方式。
    """
    kpoints_path_dict = get_kpoint_path(params)

    # 选择 kpoint_path
    lattice_type = detect_lattice_type(params)
    if params.kpoint_path.strip():
        kpoints_path_list = parse_line_path(params)
    else:
        # 根据晶格选择默认路径
        kpoints_path_list = default_kpaths.get(
            lattice_type, default_kpaths["triclinic"]
        ).split()

    # 如果只展示高对称点
    if params.show:
        # 用表格展示
        table = Table(title=f"High Symmetry Points ({lattice_type})")
        table.add_column("Label", justify="center", style="bold green")
        table.add_column("kx", justify="right")
        table.add_column("ky", justify="right")
        table.add_column("kz", justify="right")
        for i in kpoints_path_dict:
            coord = kpoints_path_dict[i]
            table.add_row(i, *(f"{c:.6f}" for c in coord))
        console.print(table)
        return  # 不生成文件

    if params.output_filename:
        output_file = str(params.output_filename)
    else:
        output_file = str("KPOINTS")

    if Path(output_file).exists():
        if not typer.confirm(f"[red]{output_file} already exists[/red]. Overwrite?"):
            console.print("[yellow]Operation cancelled.[/yellow]")
            return

    with open(output_file, "w") as f:
        f.write(f"KPOINTS generated by hbtools\n")
        f.write(f"{params.kpoint_num}\n")
        f.write(f"line-mode\n")
        f.write(f"reciprocal\n")
        for i in range(len(kpoints_path_list) - 1):
            p1 = kpoints_path_dict[kpoints_path_list[i]]
            p2 = kpoints_path_dict[kpoints_path_list[i + 1]]

            f.write(f"{p1[0]:.6f}\t{p1[1]:.6f}\t{p1[2]:.6f}\t{kpoints_path_list[i]}\n")
            f.write(
                f"{p2[0]:.6f}\t{p2[1]:.6f}\t{p2[2]:.6f}\t{kpoints_path_list[i + 1]}\n\n"
            )
    print(f"KPOINTS file written to {output_file}")


def write_kpoint_grid(params: KPOINTSParams):
    """
    网格类型的生成
    """
    with open(params.output_filename, "w") as f:
        f.write(f"KPOINTS generated by hbtools\n")
        f.write("0\n")
        f.write(f"{params.kpoints_type}\n")
        f.write(
            f"{params.kpoint_grid[0]}\t{params.kpoint_grid[1]}\t{params.kpoint_grid[2]}\n"
        )
        f.write("0\t0\t0\n")
    print(f"KPOINTS file written to {params.output_filename}")
